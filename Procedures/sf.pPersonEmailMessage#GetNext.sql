SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE sf.pPersonEmailMessage#GetNext
as
/*********************************************************************************************************************************
Sproc    : Person Email Message - Get Next
Notice   : Copyright Â© 2014 Softworks Group Inc.
Summary  : Returns email address, subject and body text for next email message to send
----------------------------------------------------------------------------------------------------------------------------------
History	: Author							| Month Year	| Change Summary
				: ------------------- + ----------- + ------------------------------------------------------------------------------------
 				: Tim Edlund          | Apr 2015		|	Initial version
				: Cory Ng							| Feb 2017		| Updated to check if queued time is now or in the past (to supported scheduled texts)
				: Tim Edlund					| Aug 2017		| Updated to avoid cancelled items (including when individual email is cancelled)
				: Tim Edlund					| Sep 2018		| Added logic to detect duplicate emails generated by triggers and to disable trigger
				: Tim Edlund					| Oct 2018		| Added logic to delete email address headers without recipients after 24 hours
				: Cory Ng							| Mar 2019		| Updated to support emails to be generated only

Comments	
--------
This procedure is called by the email service to return the next email to send.  The procedure is called by the middle tier
perpetually to send email whenever unsent mail is available.  Only the next (single email) message is returned. When no records
are available to process (an empty data set is returned), the  middle tier service waits for a period of time (about a minute) 
before calling again.

Email messages must be in a QUEUED status and not scheduled in the future to be retrieved.  Retrieval occurs in priority order
based on priority level and date. A maximum of 1 record is returned by this procedure.  The record set returned will be empty,
0 records, if no email messages are available/due for sending.

When an email is found, its sent time is automatically set to the current time (DB time). If any error is detected by the email 
service in sending the message, the service must write the message into the ChangeAudit field and update the
NotReceivedNoticeTime column to the time of the error in the USER timezone.

Duplicate Checking 
------------------
Unless specifically disabled by setting the configuration parameter "EmailSafeMode") to OFF, the procedure checks all 
trigger-based email messages for duplication.  If a trigger is configured incorrectly, it can result in many duplicate
emails being sent to the same group of people.  The procedure looks for a duplicate email sent from the same trigger
within 24 hours and if found, completes more detailed analysis where duplicate counts are averaged for all emails due or
sent in the last day from that trigger. If the procedure sees that duplicates are being created on average, and that
the sample size of Person's affected is sufficiently large, it disables the trigger and logs an error and alert for
follow-up by the help desk and/or system administrators.

Calls during maintenance windows
--------------------------------
As the email service will be down during maintenance, there is no concern about checking for off-line status.  Users will still
be able to queue emails while the email service is disabled/stopped.

Limitations
-----------
Thresholds for determining duplicates are not configurable in this version. Two hard coded setting are applied: 
	1) The value for average duplicates and 
	2) The sample size required before disabling a trigger.

Example:
--------
<TestHarness>
	<Test Name="Set Recipient List" IsDefault="false" Description="Creates a list of 5 persons and finds an un-queued email
	message.  The recipient list for the ">
		<SQLScript>
		<![CDATA[
		
			declare
				@emailMessageSID					int
				,@personList							xml
				,@messageSubscriptionSID	int
				,@emailAddress						varchar(150)		= 'testemailaddress@alinityapp.com'
				,@body										varbinary(max)
				,@subject									varchar(150)

			select
				top (1) @personList = cast('<Persons><Person PersonSID="' + cast(p.PersonSID as varchar(10)) + '" /></Persons>' as xml)
			from
				sf.Person p
			join
				sf.PersonEmailAddress pea on p.PersonSID = pea.PersonSID
	
			select
				top (1) @body = Body, @subject = [Subject], @messageSubscriptionSID = MessageSubscriptionSID
			from
				sf.EmailTemplate

			if @emailAddress is null or @body is null or @subject is null or @personList is null or @messageSubscriptionSID is null
			begin

				raiserror( '** ERROR: insufficient data to run test', 18, 1)

			end
			else
			begin
				exec sf.pEmailMessage#Insert
					@EmailMEssageSID				= @emailMessageSID output
					,@MessageSubscriptionSID	= @messageSubscriptionSID
					,@EmailAddress					= @emailAddress
					,@Subject								= @subject
					,@Body									= @body
					,@RecipientList					= @personList

				exec sf.pEmailMessage#Queue
					@EmailMEssageSID = @emailMessageSID

				waitfor delay '00:00:02'
	
				exec [sf].[pPersonEmailMessage#GetNext]

				delete from sf.PersonEmailMessage where EmailMessageSID = @emailMessageSID
				delete from sf.EmailMessage where EmailMessageSID = @emailMessageSID
			end

		]]>
		</SQLScript>
		<Assertions>
			<Assertion Type="EmptyResultSet" ResultSet="0"/>
			<Assertion Type="ExecutionTime" Value="00:00:03" />
		</Assertions>
	</Test>
</TestHarness>

exec sf.pUnitTest#Execute
	 @ObjectName = 'sf.pPersonEmailMessage#GetNext'
	,@DefaultTestOnly = 1
------------------------------------------------------------------------------------------------------------------------------- */

begin

	set nocount on;

	declare
		@errorNo							 int							 = 0																																-- 0 no error, if < 50000 SQL error, else business rule
	 ,@errorText						 nvarchar(4000)																																				-- error message for logging
	 ,@ON										 bit							 = cast(1 as bit)																										-- constant for bit comparisons = 1
	 ,@OFF									 bit							 = cast(0 as bit)																										-- constant for bit comparison = 0
	 ,@isSafeMode						 bit							 = cast(isnull(sf.fConfigParam#Value('EmailSafeMode'), 1) as bit)		-- when OFF (0) no checking for duplicate emails is performed
	 ,@isEmailOpenTracked		 bit							 = cast(isnull(sf.fConfigParam#Value('TrackEmailOpens'), 1) as bit) -- determines if email opens are tracked
	 ,@updateUser						 nvarchar(75)			 = sf.fApplicationUserSession#UserName()														-- service ID requesting the email (for audit)
	 ,@serverTime						 datetimeoffset(7) = sysdatetimeoffset()																							-- current time at database server
	 ,@cutOffTime						 datetimeoffset(7)
	 ,@personEmailMessageSID int																																									-- identity of next message to process
	 ,@personSID						 int																																									-- target user for the email message
	 ,@emailTriggerSID			 int																																									-- tracks key of trigger generating the email (if any)
	 ,@averageDuplicates		 decimal(11, 2)																																				-- average count of unsent emails for same person and subject
	 ,@sampleSize						 int;																																									-- count of recent/unsent emails for trigger being analyzed

	begin try

		select top (1)
			@personEmailMessageSID = pem.PersonEmailMessageSID
		 ,@personSID						 = pem.PersonSID
		 ,@emailTriggerSID			 = pem.EmailTriggerSID
		from
			sf.PersonEmailMessage pem
		join
			sf.EmailMessage				em on em.EmailMessageSID			= pem.EmailMessageSID
		left outer join
			sf.EmailTrigger				emltgr on pem.EmailTriggerSID = emltgr.EmailTriggerSID
		where
			pem.SentTime is null
			and em.QueuedTime is not null
			and em.QueuedTime																<= @serverTime
			and em.CancelledTime is null -- avoid cancelled, ensure queued, and not scheduled for future send
			and pem.CancelledTime is null
			and (emltgr.IsActive is null or emltgr.IsActive = @ON)	-- avoid sending from inactive triggers
		order by -- priority selection
			em.PriorityLevel
		 ,em.CreateTime
		 ,pem.PersonEmailMessageSID;

		-- unless duplicate checking has been specifically disabled for testing
		-- check for duplicates if the source of the email is a trigger

		if @isSafeMode = @ON and @emailTriggerSID is not null
		begin

			if exists
			(
				select
					1
				from
					sf.PersonEmailMessage pem
				where
					pem.PersonSID																													 = @personSID
					and pem.EmailTriggerSID																								 = @emailTriggerSID
					and pem.PersonEmailMessageSID																					 <> @personEmailMessageSID
					and (pem.SentTime is null or datediff(hour, pem.SentTime, @serverTime) < 24)	-- 2nd email sent to same person from same trigger within 24 hours
			)
			begin

				-- calculate average duplicates per person from
				-- the trigger and the number of person's affected

				select
					@averageDuplicates = avg(x.DuplicateCount)
				 ,@sampleSize				 = count(x.PersonSID)
				from
				(
					select
						pem.PersonSID
					 ,count(1) DuplicateCount
					from
						sf.PersonEmailMessage pem
					join
						sf.EmailMessage				em on em.EmailMessageSID = pem.EmailMessageSID
					where
						pem.EmailTriggerSID																										 = @emailTriggerSID
						and pem.PersonEmailMessageSID																					 <> @personEmailMessageSID
						and (pem.SentTime is null or datediff(hour, pem.SentTime, @serverTime) < 24)	-- same subject line sent to same person from this trigger within last 24 hours 
					group by
						pem.PersonSID
				) x;

				-- turn off trigger if, on average, duplicates are being created and
				-- the number of person keys affected exceeds the thresh hold

				if @sampleSize > 99 and @averageDuplicates > 1.01
				begin

					update
						sf.EmailTrigger
					set
						IsActive = @OFF
					 ,UpdateTime = @serverTime
					 ,UpdateUser = @updateUser
					where
						EmailTriggerSID = @emailTriggerSID and IsActive = @ON;

					set @errorText =
						N'Trigger appears to be creating duplicate email messages. Trigger SID = ' + ltrim(@emailTriggerSID) + N'| Average duplicates/person key = '
						+ ltrim(@averageDuplicates) + N' | Persons sampled = ' + ltrim(@sampleSize) + N'.  Trigger was disabled.';

					-- log error message and Alert for follow-up

					insert
						sf.UnexpectedError
					(
						MessageSCD
					 ,ProcName
					 ,LineNumber
					 ,ErrorNumber
					 ,MessageText
					 ,ErrorSeverity
					 ,ErrorState
					 ,SPIDNo
					 ,MachineName
					 ,DBUser
					 ,CallEvent
					 ,CallParameter
					 ,CallSyntax
					 ,CreateUser
					 ,CreateTime
					 ,UpdateUser
					 ,UpdateTime
					)
					values
					(
						'DuplicateEmailFromTrigger', N'pPersonEmailMessage#GetNext', 0, 50001, @errorText, 17, 0, @@spid, lower(host_name()), lower(suser_sname())
					 ,'pPersonEmailMessage#GetNext', 0, 'exec pPersonEmailMessage#GetNext', @updateUser, sysdatetimeoffset(), @updateUser, sysdatetimeoffset()
					);

					exec sf.pTask#Insert
						@TaskTitle = N'Trigger Generating Duplicate Emails'
					 ,@TaskDescription = @errorText
					 ,@IsAlert = @ON;

					set @personEmailMessageSID = -1;

				end;

			end;

		end;

		-- avoid EF sproc to minimize potential for record lock
		-- from another service and to minimize response time

		if isnull(@personEmailMessageSID, -1) > 0
		begin

			update
				sf.PersonEmailMessage
			set
				SentTime = @serverTime
			 ,UpdateTime = @serverTime
			 ,UpdateUser = @updateUser
			 ,ChangeAudit = sf.fChangeAudit#Comment(N'Sent by email service', ChangeAudit)
			where
				PersonEmailMessageSID = @personEmailMessageSID;

		end;

		select
			pem.RowGUID
		 ,pem.PersonEmailMessageSID
		 ,pem.PersonSID
		 ,pem.EmailMessageSID
		 ,pem.Subject
		 ,pem.Body
		 ,@isEmailOpenTracked																														 IsEmailOpenTracked
		 ,pem.EmailAddress
		 ,sf.fFormatFullName(p.LastName, p.FirstName, p.MiddleNames, np.NamePrefixLabel) FullName			--# A label for the person suitable for addressing based on name prefix (salutation) first name middle names last name
		 ,sf.fFormatDisplayName(p.LastName, isnull(p.CommonName, p.FirstName))					 DisplayName	--# A label for the person suitable for use on the UI and reports based on first name last name
		 ,em.SenderEmailAddress
		 ,em.SenderDisplayName
		 ,pem.SentTime
		 ,em.IsGenerateOnly
		from
			sf.PersonEmailMessage pem
		join
			sf.EmailMessage				em on pem.EmailMessageSID = em.EmailMessageSID
		join
			sf.Person							p on pem.PersonSID				= p.PersonSID
		left outer join
			sf.NamePrefix					np on p.NamePrefixSID			= np.NamePrefixSID
		where
			pem.PersonEmailMessageSID = @personEmailMessageSID;

		-- if no email messages are due for sending, delete messages
		-- created without recipients that are more than 24 hours old

		if @personEmailMessageSID is null
		begin

			set @cutOffTime = dateadd(hour, -24, @serverTime);

			delete
			em
			from
				sf.EmailMessage em
			join
			(
				select
					em.EmailMessageSID
				from
					sf.EmailMessage				em
				left outer join
					sf.PersonEmailMessage pem on em.EmailMessageSID = pem.EmailMessageSID
				where
					pem.PersonEmailMessageSID is null
			)									x on em.EmailMessageSID = x.EmailMessageSID
			where
				em.CreateTime < @cutOffTime;

		end;

	end try
	begin catch
		exec @errorNo = sf.pErrorRethrow;
	end catch;

	return (@errorNo);

end;
GO
