SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [sf].[pEntitySetVerify]
	(
	 @VerifyMode                char(1)          = 'p'          -- determines entities to select for processing: a-ll, i-dentifiers, s-chema, p-ending 
	,@ApplicationEntitySID			int							 = null         -- PK key value of 1 entity to validate - required when @VerifyMode = 'i'
	,@SchemaName                nvarchar(128)    = null         -- specific schema to process entities for - where @VerifyMode = 's'
	,@EntityCount               int							 = null output	-- optional output parameter to report count of entities processed
	,@TotalRowCount             int              = null output  -- count of rows checked (cumulative - all entities processed)	
	,@TotalRuleCount            int              = null output  -- count of rules checked (cumulative - all entities processed)	  
	,@TotalErrorCount           int              = null output  -- count of errors encountered (cumulative - all entities processed)
	,@ReturnSelect              bit              = 0            -- when 1 output values are returned as a dataset
	,@JobRunSID									int							 = null					-- sf.JobRun record to update on asynchronous calls
	)
as
/*********************************************************************************************************************************
Procedure : sf.pEntitySetVerify
Notice    : Copyright Â© 2014 Softworks Group Inc.
Summary   : calls p<table>#Verify procedures for one or more entities in the database
History		: Author(s)  	| Month Year	| Change Summary
					: ------------|-------------|-------------------------------------------------------------------------------------------
					: Tim Edlund	| Aug		2011	|	Initial version
					: Tim Edlund	| Nov		2015	| Updated to store a color into a configuration parameter after checking is complete to 
																				indicate whether business rule errors exist in the DB.

Comments	
--------
This procedure is used to call the p<tableName>#Verify routines which check business rules on tables.  The procedure can be called
synchronously or asynchronously (through the Job Management sub-system).  For asynchronous calling pass the @JobRunSID parameter
so that the procedure updates the sf.JobRun record to advise the UI of progress.

The procedure supports 4 different calling modes to determine the tables that will be verified (settings of @VerifyMode):

'a'   Call ALL #verify routines. This option checks every table in the database. The list of tables is returned from vTable
			but excludes tables which begin with underscore (by convention are considered temporary tables) and system tables.
			
'i'   Identifier.  This option requires that the @ApplicationEntitySID parameter be passed with a SINGLE EntitySID value. Note
			that when the @ApplicationEntitySID parameter is not null, the @VerifyMode is automatically set to 'i'.

's'   Schema tables. This option is used primarily after upgrades where a specific schema - e.g. the sf (Softworks Framework)
			schema has been updated. 
			
'p'   Pending is the default verification mode. When this mode is passed the application inspects the status of the entity
			and business rules to call the verification routine on all entities where: 1) a rule is marked pending or 2) where
			the check constraint is not enabled on the entity.
			
Note that before beginning the process of the p-ending option, the procedure first ensures that any mandatory rule marked off
(x), is set to a status of pending (p). This is meant to handle the situation where a developer has turned off one or more
mandatory rules in order to complete a conversion task, and forgot to re-enable it.  The update ensures the rule is processed
on the next run of this routine.

To check rules on a particular schema - pass BOTH the @VerifyMode = 's' AND the @SchemaName. 

Depending on the option selected and size of the database, this procedure may require a great deal of time to complete. This 
procedure should be called asynchronously.  The application will timeout if a direct call is made from the UI.  Note that in 
asynchronous calls the record counts reported in progress updates are the count of entities - not records.  The actual number
of records processed is recorded when final results are posted to the sf.JobRun record when the routine finishes.

The SGI standard for enforcing business rules, except those that apply only on DELETE, is to use a check constraint.  A single
check constraint is implemented on each table. The one constraint checks all business rules by calling a function and passing
it all columns in the table. The syntax for the function can be Generated by DB Studio.  Another procedure - also generated
by SGI Studio - can be used to "batch verify" all records in the table. Batch verification is required even where a CHECK
constraint is active on a table because some rules can be turned on optionally - using meta data in the framework - and
if this is done after records are entered into the table, older rows are not checked.

This procedure calls the batch verify routines for the tables selected. 

See p<tableName>#Verify and f<TableName>#Check routines for additional details on any specific table's verification rules.

Example
-------

exec sf.pEntitySetVerify																									-- process all p-ending entities (the default)
	@ReturnSelect = 1

exec sf.pEntitySetVerify																									-- process for a specific list of entity SID's
	 @VerifyMode = 'i' 
	,@ApplicationEntitySID = 1000001
	,@ReturnSelect = 1
 
exec sf.pEntitySetVerify																									-- process all entities
	 @VerifyMode = 'a' 
	,@ReturnSelect = 1  

select * from sf.vBusinessRuleError  

--------------------------------
-- call the job asynchronously 
--------------------------------

declare
	 @CRLF								nchar(2) = char(13) + char(10)										-- constant for formatting job syntax script
	,@jobSID							int																								-- key of the sf.Job#Simulate record in sf.Job		
	,@jobSCD							varchar(128)																			-- code for the job to insert
	,@callSyntaxTemplate	nvarchar(max)																			-- syntax for the job with replacement tokens
	,@parameters					xml																								-- buffer to record parameters for the call syntax
	,@conversationHandle	uniqueidentifier																	-- ID assigned to each job conversation

set @jobSCD = 'sf.pEntitySetVerify'																				-- add the job syntax if not already established 

select
	@jobSID = j.JobSID
from
	sf.Job j
where
	j.JobSCD = @jobSCD

if @jobSID is null
begin

	set @callSyntaxTemplate = 
		'exec ' + @jobSCD
		+ @CRLF + '   @JobRunSID            = {JobRunSID}'
		+ @CRLF + '  ,@VerifyMode           = ''{p1}'''
		+ @CRLF + '  ,@ApplicationEntitySID = {p2}'

	exec sf.pJob#Insert
		 @JobSID							= @jobSID		output
		,@JobSCD							= @jobSCD
		,@JobLabel						= N'Business rule verification'
		,@JobDescription			= N'Checks data in the system to ensure it complies with all currently-enabled business rules.'
		,@CallSyntaxTemplate	= @callSyntaxTemplate

end

set @parameters = cast(N'<Parameters p1="p" p2="null"/>' as xml)					-- process p-ending verifications

exec sf.pJob#Call
	 @JobSCD							= @jobSCD
	,@Parameters					= @parameters

waitfor delay '00:00:03'																									-- wait for job to start

select top 3																															-- use this select to monitor the job
	*
from
	sf.vJobRun jr
order by
	jr.UpdateTime desc

-------------------------------------------------------------------------------------------------------------------------------- */

set nocount on

begin

	declare
		 @errorNo                         int = 0                             -- 0 no error, <50000 SQL error, else business rule
		,@errorText                       nvarchar(4000)                      -- message text (for business rule errors)    
		,@ON                              bit = cast(1 as bit)                -- used on bit comparisons to avoid multiple casts
		,@OFF                             bit = cast(0 as bit)                -- used on bit comparisons to avoid multiple casts
		,@CRLF														nchar(2)	= char(13) + char(10)			-- carriage return line feed for formatting text blocks
		,@TAB															nchar(1)	= char(9)									-- tab character for formatting text blocks
		,@blankParm												varchar(128)												-- name of required parameter left blank
		,@termLabel												nvarchar(35)												-- buffer for configurable label text
		,@systemUser                      nvarchar(75)												-- for audit details recorded on error log
		,@maxRow													int																	-- loop limit
		,@i                               int																	-- loop index
		,@verifySprocName                 nvarchar(257)												-- procedure to call for the next entity
		,@nextRowCount                    int																	-- tracks rows processed on each #verify call
		,@nextRuleCount                   int																	-- tracks rules processed on each #verify call		
		,@nextErrorCount                  int																	-- tracks errors encountered on each #verify call  
		,@execSQL                         nvarchar(500)												-- string for dynamic execution of #verify procedure                             
		,@parmSQL                         nvarchar(500)												-- string for declaration of parameters to #verify
		,@isCancelled											bit		= 0														-- checks for cancellation request on async job calls  
		,@recordsProcessed								int		= 0														-- running total of entities processed   		
		,@currentProcessLabel							nvarchar(35)												-- label for stage of work
		,@dbStatusColor                   char(9)															-- color to display DB status in (hex format)
		,@configParamSID									int																	-- key of parameter row for update of final DB status
		,@resultMessage										nvarchar(4000)											-- summary of job result
		,@traceLog												nvarchar(max)												-- text block for detailed results of job
		
	declare   
		@work                                 table                           -- table of entities to process  
		(
			 ID                   int           identity(1,1)
			,ApplicationEntitySID int           not null
			,VerifySprocName      nvarchar(257) null
			,IsComplete						bit						not null default cast(0 as bit)
		)

	set @EntityCount      = 0                                                 -- ensure output set for all code paths
	set @TotalRowCount    = 0
	set @TotalRuleCount   = 0
	set @TotalErrorCount  = 0

	begin try

		if @JobRunSID is not null																							-- if call is async, update the job run record
		begin

			exec sf.pTermLabel#Get															
				 @TermLabelSCD	= 'SELECTING.RECORDS'
				,@TermLabel			= @termLabel output
				,@DefaultLabel	= N'Selecting records ...'
				,@UsageNotes    = N'A label reporting processing status when records are being selected for the operation.'

			exec sf.pJobRun#Update
				 @JobRunSID						= @JobRunSID
				,@CurrentProcessLabel = @termLabel

			set @traceLog	= sf.fPadR(N'V E R I F I C A T I O N   S U M M A R Y', 50)											-- format header for trace log
													+ @TAB + ' Records' + @TAB + '   Rules' + @TAB + '  Errors'
													+ @CRLF + sf.fPadR('---------------------------------------', 50)
													+ @TAB + '--------' + @TAB + '--------' + @TAB + '--------'

		end

		-- check parameters
		
		if @ApplicationEntitySID is not null set @VerifyMode = 'i'
		if @SchemaName					 is not null set @VerifyMode = 's'
		
		if @VerifyMode = 's' and @SchemaName						is null set @blankParm = '@SchemaName'		
		if @VerifyMode = 'i' and @ApplicationEntitySID	is null set @blankParm = '@ApplicationEntitySID'
		if @VerifyMode is null																	set @blankParm = '@VerifyMode'

		if @blankParm is not null
		begin

			exec sf.pMessage#Get
				 @MessageSCD  	= 'BlankParameter'
				,@MessageText 	= @errorText output
				,@DefaultText 	= N'A parameter (%1) required by the database procedure was left blank.'
				,@Arg1					= @blankParm

			raiserror(@errorText, 18, 1)
		end		

		if @VerifyMode not in ('a', 'i', 's', 'p')
		begin

			exec sf.pMessage#Get
				 @MessageSCD  	= 'MBR.UnrecognizedCode'
				,@MessageText 	= @errorText output
				,@DefaultText 	= N'The code value for %1 provided (%2) is unrecognized.  Expected code values are: %3.'
				,@Arg1					= '@VerifyMode'
				,@Arg2					= @VerifyMode
				,@Arg3					= '"a"(all), "i"(identifier list), "s"(schema), "p"(pending)'
			
			raiserror(@errorText, 18, 1)
		end

		set @systemUser = isnull(left(sf.fConfigParam#Value('SystemUser'),75), sf.fApplicationUserSession#UserName())

		if @VerifyMode = 'a'
		begin

			-- for "all" mode only, remove previous error log records - set audit
			-- information for CDC tracking via update before making deletion

			begin transaction

			update
				sf.BusinessRuleError
			set
				 IsDeleted  = 1
				,UpdateUser = @systemUser
				,UpdateTime = sysdatetimeoffset()
			
			delete sf.BusinessRuleError                                         -- delete all prior messages ("all" mode only)
			dbcc checkident('sf.BusinessRuleError',reseed, 1000000) with NO_INFOMSGS
			
			commit
		
			insert
				@work (ApplicationEntitySID, VerifySprocName)
			select
				 ae.ApplicationEntitySID
				,convert(nvarchar(128), ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify')
			from
				sf.vApplicationEntity ae                                          -- all entities
			where
				(ae.BaseTableSchemaName <> 'stg' or  object_id( ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify' ) > 0)			-- verify sprocs do not exist on all tables in STG (but should elsewhere)
			order by
				ae.ApplicationEntitySCD
		
		end
		else if @VerifyMode = 'i'
		begin
		
			insert
				@work (ApplicationEntitySID, VerifySprocName)
			select
				 ae.ApplicationEntitySID
				,convert(nvarchar(128), ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify')
			from
				sf.vApplicationEntity ae
			where
				ae.ApplicationEntitySID = @ApplicationEntitySID	
		
		end
		else if @VerifyMode = 's'
		begin
		
			insert
				@work (ApplicationEntitySID, VerifySprocName)
			select
				 ae.ApplicationEntitySID
				,convert(nvarchar(128), ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify')
			from
				sf.vApplicationEntity ae                                                                 
			where
				ae.BaseTableSchemaName = @SchemaName                              -- entities for a given schema
			and
				(ae.BaseTableSchemaName <> 'stg' or  object_id( ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify' ) > 0)			
			order by
				ae.ApplicationEntitySCD
		
		end
		else
		begin

			-- ensure application entity table reflects the actual tables in the 
			-- schema - use setup synchronization procedure

			exec sf.pSetup$ApplicationEntity	
				 @SetupUser = @systemUser
				,@Language = 'en'

			-- ensure all mandatory rules for all tables are marked enabled
			-- (corrects missing resets after configuration/conversion tasks)

			update
				br
			set
				 BusinessRuleStatus = 'p'
				,UpdateUser          = @systemUser
				,UpdateTime          = sysdatetimeoffset()
			from
				sf.BusinessRule  br
			join
				sf.vBusinessRule#Ext brx on br.BusinessRuleSID = brx.BusinessRuleSID
			where
				brx.IsMandatory = 1
			and
				br.BusinessRuleStatus = 'x'
					
			-- include all entities where 1 or more rules are pending, or, the
			-- check constraint is not enabled        

			insert
				@work (ApplicationEntitySID, VerifySprocName)
			select
				 ae.ApplicationEntitySID
				,convert(nvarchar(128), ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify')
			from
				sf.vApplicationEntity ae                                                                 
			where
				(ae.BaseTableSchemaName <> 'stg' or  object_id( ae.BaseTableSchemaName + N'.p' + ae.BaseTableName + '#Verify' ) > 0)			-- verify sprocs do not exist on all tables in STG (but should elsewhere)
			and
			(
				ae.IsConstraintEnabled = 0
			or
				isnull(ae.PendingBusinessRuleCount,0) > 0
			)
			order by
				ae.ApplicationEntitySCD		  
		
		end

		-- remove RPT table verifications that do not exist in the schema; most RPT
		-- tables are generated for reporting and will not have verification sprocs

		delete
			w
		from
			@work w
		left outer join
			sf.vRoutine r on w.VerifySprocName = r.SchemaAndRoutineName
		where
			isnull(w.VerifySprocName, N'x') like N'rpt.%'
		and
			r.RoutineName is null
		
		select
			 @maxRow			= isnull(max(ID),0)
			,@EntityCount = count(1)
		from
			@work

		-- unless p-ending mode is active, at least one entity
		-- should have been loaded into the work table for processing
		
		if @EntityCount = 0 and @VerifyMode <> 'p'
		begin

			exec sf.pMessage#Get
				 @MessageSCD  	= 'NoRecordsSelected'
				,@MessageText 	= @errorText output
				,@DefaultText 	= N'No %1 were found matching the criteria provided.'
				,@Arg1					= 'entities'

			raiserror(@errorText, 17, 1)
		end		

		set @i = 0

		while @i < @maxRow and @isCancelled = @OFF
		begin

			select 
				@i = min(w.ID)
			from
				@work w
			where
				w.ID > @i
		
			set @verifySprocName = null
			
			select
				@verifySprocName = w.VerifySprocName
			from  
				@work w
			where
				w.ID = @i

			-- if an async call, update the processing label but not the 
			-- record count prior to calling the verification

			if @JobRunSID is not null
			begin

				-- check if a cancellation request occurred
				-- where job is running in async mode

				if exists
				(
					select
						1
					from
						sf.JobRun jr
					where
						jr.CancellationRequestTime is not null
					and
						jr.JobRunSID = @JobRunSID
				)
				begin
					set @isCancelled = @ON
				end

				set @currentProcessLabel	= cast(replace(replace(@verifySprocName, N'.p', '.'), '#Verify', '') + ' ...' as nvarchar(35))	-- get table name being processed

				exec sf.pJobRun#Update
					 @JobRunSID						= @JobRunSID
					,@CurrentProcessLabel = @currentProcessLabel
					,@IsCancelled					= @isCancelled

			end

			-- if verify sproc is missing raise an error 
				
			if @verifySprocName is null																			
			begin
			
				exec sf.pMessage#Get
					 @MessageSCD  	= 'ProcedureMissing'
					,@MessageText 	= @errorText output
					,@DefaultText 	= N'A standard procedure required by the application "%1" was not found.'
					,@Arg1					= @verifySprocName

				raiserror(@errorText, 18, 1)
				
			end
			
			-- use dynamic SQL to call the procedure and accumulate the
			-- count of errors to the output parameter
			
			set @nextErrorCount = 0
			set @execSQL        = N'exec ' + @verifySprocName + ' @RowCount output, @RuleCount output, @ErrorCount output'
			set @parmSQL        = N'@RowCount int output, @RuleCount int output, @ErrorCount int output'
			
			exec sp_executesql
				 @execSQL
				,@parmSQL
				,@RowCount   = @nextRowCount   output
				,@RuleCount  = @nextRuleCount  output        
				,@ErrorCount = @nextErrorCount output
							
			set @TotalRowCount   += @nextRowCount
			set @TotalRuleCount  += @nextRuleCount
			set @TotalErrorCount += @nextErrorCount

			-- update the record count and the result message with 
			-- counts for the table just processed

			if @JobRunSID is not null
			begin

				set @recordsProcessed	+= 1
				
				set @traceLog += @CRLF + sf.fPadR(replace(replace(@verifySprocName, N'.p', '.'), '#Verify', ''),50) 
											+  @TAB + sf.fPadL(ltrim(@nextRowCount), 8) + @TAB + sf.fPadL(ltrim(@nextRuleCount), 8) + @TAB + sf.fPadL(ltrim(@nextErrorCount), 8)
		
				if exists
				(
					select
						1
					from
						sf.JobRun jr
					where
						jr.CancellationRequestTime is not null
					and
						jr.JobRunSID = @JobRunSID
				)
				begin
					set @isCancelled = @ON
				end

				exec sf.pJobRun#Update
					 @JobRunSID						= @JobRunSID
					,@RecordsProcessed		= @recordsProcessed
					,@TotalRecords				= @EntityCount
					,@CurrentProcessLabel = @currentProcessLabel
					,@IsCancelled					= @isCancelled

			end

			update
				@work
			set
				IsComplete = @ON
			where
				ID = @i
			
		end

		-- update job with final totals for actually records processed
		-- and errors encountered

		if @JobRunSID is not null and @isCancelled = @OFF
		begin

			if @EntityCount = 0 
			begin

				exec sf.pMessage#Get
					 @MessageSCD  	= 'NoTablesFoundToVerify'
					,@MessageText 	= @resultMessage output
					,@DefaultText 	= N'Warning: No tables were found with pending verifications.  (This is not an error.)'

				set @traceLog			 = N'(No tables processed)'
			end
			else
			begin

				exec sf.pMessage#Get
					 @MessageSCD  	= 'JobCompletedSucessfully'
					,@MessageText 	= @resultMessage output
					,@DefaultText 	= N'The %1 job was completed successfully.'
					,@Arg1					= 'verification'

			end

			exec sf.pJobRun#Update								
				 @JobRunSID						= @JobRunSID
				,@TotalRecords				= @TotalRowCount
				,@RecordsProcessed		= @TotalRowCount
				,@TotalErrors					= @TotalErrorCount
				,@TraceLog						= @traceLog																	-- post detailed summary report to trace log
				,@ResultMessage				= @resultMessage

		end
		
		if @ReturnSelect = 1
		begin
		
			select
				 @EntityCount     EntityCount
				,@TotalRowCount   TotalRowCount
				,@TotalRuleCount  TotalRuleCount
				,@TotalErrorCount TotalErrorCount
				
		end

		-- update the database status configuration parameter with 
		-- a normal or highlight color depending on whether business
		-- rule errors exist in the DB

		select
			@configParamSID = cp.ConfigParamSID
		from
			sf.ConfigParam cp
		where
			cp.ConfigParamSCD = 'DatabaseStatusColor'

		if @configParamSID is not null																				-- avoid update if parameter is missing
		begin

			if exists(select 1 from sf.vApplicationEntity ae where ae.DataStatus <> 'v' and ae.BaseTableSchemaName <> 'stg' and ae.BaseTableSchemaName <> 'rpt') 
			begin
				set @dbStatusColor = cast(isnull(sf.fConfigParam#Value('DatabaseNameErrorColor'), '#FFB80000') as char(9))								-- allows override of standard color
			end
			else
			begin
				set @dbStatusColor = cast(isnull(sf.fConfigParam#Value('DatabaseNameValidColor'), '#FF0a3e5a') as char(9))								-- allows override of standard color
			end

			exec sf.pConfigParam#Update
				 @ConfigParamSID  = @configParamSID
				,@ParamValue			= @dbStatusColor

		end

	end try

	begin catch

		if @@trancount > 0 rollback																						-- roll back any pending trx so that update can succeed

		if @JobRunSID is null
		begin

			select																															-- return progress information for follow-up
				 w.ID
				,w.VerifySprocName
				,w.IsComplete
			from
				@work w
			order by
				w.ID

			print @execSQL																											-- send debugging information to the console

		end
		else
		begin

			exec sf.pTermLabel#Get															
				 @TermLabelSCD	= 'JOB.FAILED'
				,@TermLabel			= @termLabel output
				,@DefaultLabel	= N'*** JOB FAILED'
				,@UsageNotes    = N'A label reporting failure of jobs (normally accompanied by error report text from the database).'

			set @errorText = @termLabel + isnull(N' AT : ' + @verifySprocName + @CRLF, N'')
			set @errorText += @CRLF + error_message()

			exec sf.pJobRun#Update
				 @JobRunSID			= @JobRunSID
				,@ResultMessage = @errorText
				,@TraceLog			= @traceLog																				-- post interim result message to trace log for debugging
				,@IsFailed			= @ON

		end

		exec @errorNo = sf.pErrorRethrow                                      -- catch the error, rollback if pending, and re-throw

	end catch

	return(@errorNo)

end
GO
