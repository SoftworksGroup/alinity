SET ANSI_NULLS ON
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE dbo.pPayment#GetPending
	@ApplicationUserSID int = null	-- limit pending payments to a specific application user only (called at login)
as
/*********************************************************************************************************************************
Sproc    : Payment - Get Pending
Notice   : Copyright Â© 2018 Softworks Group Inc.
Summary  : Returns credit card payment records where response is received but not applied to the record 
----------------------------------------------------------------------------------------------------------------------------------
History	: Author							| Month Year	| Change Summary
				: ------------------- + ----------- + ------------------------------------------------------------------------------------
 				: Tim Edlund          | Oct 2018		|	Initial version
				: Cory Ng							| Feb 2019		| Returned payment type SCD, used in determining how to reapply the payment

Comments	
--------
This procedure is called by a regularly scheduled Service, and at login to check if any credit card payments have been left in 
a pending state where "verification" information has been received for it from the credit card processor.  When this scenario
occurs, the payment will not be applied and generation of registration records may be blocked.  This procedure returns payment
records in this scenario for processing by the client/service tier.  The client/service tier code parses the results stored
by the process and updates the dbo.Payment record through dbo.pPayment#Update. If full payment on a registration invoice 
has been received, required registration records are created.

The procedure is designed to recover from the scenario where a communication failure occurs after the user clicks "Pay" on
the credit card page at the end of their payment process. If no response was received from the credit card processor, the 
transaction will appear to be unpaid. This may occur because the user immediately closes their browser after clicking the Pay 
option, or because of a general connection failure where the client browser is no longer connected to the Internet. 

A separate service running outside the browser "server-to-server" between the credit card processor and Alinity also saves the
Verified Time into the (dbo) Payment Processor Response table.  This procedure looks for payment records where a result has
been received but the payment record remains in a pending status.  A lag interval is applied to avoid returning records
which are currently being processed by browser session.  

The @ApplicationUserSID parameter is provided to call the procedure during the login process so that results are limited to
a specific user. That parameter is used during calls during the login process.  This is particularly helpful where a
communication error occurred for the user when processing their credit card and they are logging back in to check on
results.  If the result from the card processor was not captured through the browser, this procedure will return the
record and the client-tier processes the result.  The end result is that the payment is fully processed and any required
registration records generated by the time the Member dashboard is rendered.

See the dbo.pPayment#Update procedure to see the logic for how payments result in triggering the generation of new
Registration records for fully paid Renewal, Reinstatement, Application and Registration Change invoices.

When this procedure is called through the regularly scheduled service, an interval of 5-10 minutes is recommended. The
procedure may return 0, 1 or multiple records.  The caller must support processing of multiple records. 

Limitations
-----------
If an error is raised when the dbo.pPayment#Update procedure is executed by the caller for a payment returned by this
procedure, that payment will still be returned on the next call to this procedure.  In that sense, the failing record becomes 
a "poison pill" and the cycle of returning the record for processing, and the process failing will repeat. Failures are logged
in sf.UnexpectedError.  Where the procedure is called every 15 seconds, this will result in nearly 6,000 logged errors in 
every 24 hour period.  To avoid repeated processing of the record, the caller must either set the CancelledTime column on 
the record or, implement an ERROR status on the dbo.Payment.

Monitoring Pending Payment Scenarios
------------------------------------
This procedure is called at login.  If a user loses their Internet connection after clicking "Pay" but does not return to the
application to login again and check for a result, then no update will occur immediately.  The update will only occur once 
the regularly scheduled service processes the record.

Administrators can, however, detect this scenario with product queries that check for pending transactions on the Payment
Management page.  If the payment is pending, but no result has been received for them from the credit card processor, this
procedure will not resolve the problem.  The Administrator must go to their credit card processor page to investigate whether
a result for the transaction is available.

Another scenario that administrators can monitor is the situation where a form (especially "Renewal") appears paid but no
registration has been created. Another set of product queries (on the Registrations page) is available for monitoring - example:
"Paid not renewed".  

Example
-------
<TestHarness>
  <Test Name = "Default" IsDefault ="true" Description="Executes the procedure to return pending records (all users).
	Data set returned may be blank.">
    <SQLScript>
      <![CDATA[

exec dbo.pPayment#GetPending

		]]>
    </SQLScript>
    <Assertions>
      <Assertion Type="ExecutionTime" Value="00:00:03"/>
    </Assertions>
  </Test>
  <Test Name = "DataSet" Description="Executes the procedure for an application user selected at random. Data set
	returned may be blank.">
<SQLScript>
      <![CDATA[
declare @applicationUserSID int;

select top (1)
	@applicationUserSID = au.ApplicationUserSID
from
	dbo.RegistrantRenewal rnw
join
	dbo.Invoice						i on rnw.InvoiceSID		 = i.InvoiceSID
join
	dbo.InvoicePayment		ipmt on rnw.InvoiceSID = ipmt.InvoiceSID
join
	sf.Person							p on i.PersonSID			 = p.PersonSID
join
	sf.ApplicationUser		au on p.PersonSID			 = au.PersonSID
order by
	newid();

if @@rowcount = 0 or @applicationUserSID is null
begin
	raiserror('** ERROR ** No Suitable Data Found For Test!', 17, 1);
end;
else
begin

	exec dbo.pPayment#GetPending
		@ApplicationUserSID = @applicationUserSID;

end;
		]]>
    </SQLScript>
    <Assertions>
      <Assertion Type="NotEmptyResultSet" ResultSet="1"/>
      <Assertion Type="ExecutionTime" Value="00:00:03"/>
    </Assertions>
  </Test>
</TestHarness>

exec sf.pUnitTest#Execute
	 @ObjectName = 'dbo.pPayment#GetPending'
	,@DefaultTestOnly = 1
------------------------------------------------------------------------------------------------------------------------------- */

begin

	set nocount on;

	declare
		@errorNo		int								= 0											-- 0 no error, <50000 SQL error, else business rule
	 ,@errorText	nvarchar(4000)														-- message text for business rule errors
	 ,@personSID	int																				-- person to search for pending payments
	 ,@cutoffTime datetimeoffset(7) = sysdatetimeoffset();	-- current time

	begin try

		-- when not being called for a specific user, move cut off 
		-- back 2 minutes to avoid hitting payments currently in process

		if @ApplicationUserSID is null
		begin
			set @cutoffTime = dateadd(minute, -2, @cutoffTime);
			set @personSID = -1
		end;
		else
		begin

			select
				@personSID = au.PersonSID
			from
				sf.ApplicationUser au
			where
				au.ApplicationUserSID = @ApplicationUserSID;

			if @personSID is null
			begin

				exec sf.pMessage#Get
					@MessageSCD = 'RecordNotFound'
				 ,@MessageText = @errorText output
				 ,@DefaultText = N'The %1 record was not found. Record ID = "%2". The record may have been deleted or the identifier is invalid.'
				 ,@Arg1 = 'sf.ApplicationUser'
				 ,@Arg2 = @ApplicationUserSID;

				raiserror(@errorText, 18, 1);
			end;

		end;

		select
			pmt.PaymentSID
		 ,pmt.PaymentProcessorResponseSID
		 ,pmt.ResponseTime
		 ,pmt.TransactionID
		 ,pmt.ResponseSource
		 ,pmt.ResponseDetails
		 ,pmt.PaymentTypeSCD
		from
			dbo.fPayment#GetPending(@personSID, @cutoffTime) pmt

	end try
	begin catch
		exec @errorNo = sf.pErrorRethrow;
	end catch;

	return (@errorNo);

end;
GO
